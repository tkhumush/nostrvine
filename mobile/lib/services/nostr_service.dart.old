// ABOUTME: Production NostrService implementation with embedded relay functionality
// ABOUTME: Cross-platform Nostr protocol operations with local SQLite storage

import 'dart:async';

import 'package:flutter_embedded_nostr_relay/flutter_embedded_nostr_relay.dart' as embedded;
import 'package:logging/logging.dart';
import 'package:nostr_sdk/event.dart';
import 'package:nostr_sdk/filter.dart';
import 'package:openvine/models/nip94_metadata.dart';
import 'package:openvine/services/nostr_key_manager.dart';
import 'package:openvine/services/nostr_service_interface.dart';

/// Production implementation of NostrService with embedded relay functionality
/// Uses flutter_embedded_nostr_relay for SQLite persistence and P2P sync
class NostrService implements INostrService {
  NostrService(this._keyManager);
  
  final NostrKeyManager _keyManager;
  late embedded.EmbeddedNostrRelay _embeddedRelay;
  
  final Map<String, StreamController<Event>> _subscriptions = {};
  final Map<String, embedded.Subscription> _relaySubscriptions = {};
  final Map<String, bool> _relayAuthStates = {};
  final _authStateController = StreamController<Map<String, bool>>.broadcast();
  
  bool _isInitialized = false;
  bool _isDisposed = false;
  
  // External relay URLs for network sync
  // Default to OpenVine's relay, but allow adding more
  final List<String> _externalRelays = [];
  
  @override
  Future<void> initialize({List<String>? customRelays}) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (_isInitialized) return; // Already initialized
    
    print('NostrService: Initializing embedded relay with SQLite persistence');
    
    // Initialize the embedded relay
    _embeddedRelay = embedded.EmbeddedNostrRelay();
    await _embeddedRelay.initialize(
      logLevel: Level.INFO,
      enableGarbageCollection: true,
    );
    
    // Use OpenVine's relay as default, or custom relays if provided
    final defaultRelay = 'wss://relay3.openvine.co';
    final relaysToAdd = customRelays ?? [defaultRelay];
    
    for (final relayUrl in relaysToAdd) {
      try {
        await _embeddedRelay.addExternalRelay(relayUrl);
        _externalRelays.add(relayUrl);
        print('NostrService: Added external relay: $relayUrl');
        _relayAuthStates[relayUrl] = true;
      } catch (e) {
        print('NostrService: Failed to add relay $relayUrl: $e');
        _relayAuthStates[relayUrl] = false;
      }
    }
    
    // Mark as authenticated for embedded functionality
    _relayAuthStates['embedded://local'] = true;
    _authStateController.add(Map.from(_relayAuthStates));
    
    _isInitialized = true;
    print('NostrService: Embedded relay initialized with ${_externalRelays.length} external relays');
  }

  @override
  bool get isInitialized => _isInitialized;

  @override
  bool get isDisposed => _isDisposed;

  @override
  List<String> get connectedRelays => ['embedded://local', ..._externalRelays];

  @override
  String? get publicKey => _keyManager.publicKey;

  @override
  bool get hasKeys => _keyManager.hasKeys;

  @override
  NostrKeyManager get keyManager => _keyManager;

  @override
  int get relayCount => _externalRelays.length + 1; // +1 for embedded

  @override
  int get connectedRelayCount => _relayAuthStates.values.where((v) => v).length;

  @override
  List<String> get relays => connectedRelays;

  @override
  Map<String, dynamic> get relayStatuses => Map.fromIterable(
    connectedRelays,
    key: (relay) => relay,
    value: (relay) => {'connected': true, 'authenticated': _relayAuthStates[relay] ?? false},
  );

  @override
  Map<String, bool> get relayAuthStates => Map.from(_relayAuthStates);

  @override
  Stream<Map<String, bool>> get authStateStream => _authStateController.stream;

  @override
  bool isRelayAuthenticated(String relayUrl) => _relayAuthStates[relayUrl] ?? false;

  @override
  bool get isVineRelayAuthenticated => _relayAuthStates.values.any((auth) => auth);

  @override
  void setAuthTimeout(Duration timeout) {
    // Implementation for auth timeout if needed
  }

  @override
  Stream<Event> subscribeToEvents({required List<Filter> filters, bool bypassLimits = false}) {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    final controller = StreamController<Event>();
    final id = 'sub_${DateTime.now().millisecondsSinceEpoch}';
    _subscriptions[id] = controller;
    
    // Convert Filter to embedded.Filter and subscribe
    final embeddedFilters = filters.map(_convertToEmbeddedFilter).toList();
    
    final subscription = _embeddedRelay.subscribe(
      filters: embeddedFilters,
      onEvent: (embeddedEvent) {
        try {
          final event = _convertFromEmbeddedEvent(embeddedEvent);
          if (!controller.isClosed) {
            controller.add(event);
          }
        } catch (e) {
          print('NostrService: Error converting event: $e');
        }
      },
      onEose: () {
        // End of stored events signal
        print('NostrService: EOSE for subscription $id');
      },
    );
    
    _relaySubscriptions[id] = subscription;
    
    return controller.stream;
  }

  @override
  Future<NostrBroadcastResult> broadcastEvent(Event event) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    // Convert to embedded event and publish
    final embeddedEvent = _convertToEmbeddedEvent(event);
    
    try {
      await _embeddedRelay.publish(embeddedEvent);
      
      // Success - event stored locally and will sync to external relays
      return NostrBroadcastResult(
        event: event,
        successCount: 1,
        totalRelays: 1,
        results: {'embedded://local': true},
        errors: {},
      );
    } catch (e) {
      return NostrBroadcastResult(
        event: event,
        successCount: 0,
        totalRelays: 1,
        results: {'embedded://local': false},
        errors: {'embedded://local': e.toString()},
      );
    }
  }

  @override
  Future<void> dispose() async {
    if (_isDisposed) return;
    
    _isDisposed = true;
    
    // Close all subscriptions
    for (final controller in _subscriptions.values) {
      await controller.close();
    }
    _subscriptions.clear();
    
    // Close relay subscriptions
    for (final sub in _relaySubscriptions.values) {
      sub.close();
    }
    _relaySubscriptions.clear();
    
    // Shutdown embedded relay
    await _embeddedRelay.shutdown();
    
    await _authStateController.close();
    
    print('NostrService: Disposed');
  }

  @override
  Future<bool> addRelay(String relayUrl) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    if (!_externalRelays.contains(relayUrl)) {
      try {
        await _embeddedRelay.addExternalRelay(relayUrl);
        _externalRelays.add(relayUrl);
        _relayAuthStates[relayUrl] = true;
        _authStateController.add(Map.from(_relayAuthStates));
        print('NostrService: Added relay: $relayUrl');
        return true;
      } catch (e) {
        print('NostrService: Failed to add relay $relayUrl: $e');
        _relayAuthStates[relayUrl] = false;
        return false;
      }
    }
    return true; // Already added
  }

  @override
  Future<void> removeRelay(String relayUrl) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    if (_externalRelays.contains(relayUrl)) {
      await _embeddedRelay.removeExternalRelay(relayUrl);
      _externalRelays.remove(relayUrl);
      _relayAuthStates.remove(relayUrl);
      _authStateController.add(Map.from(_relayAuthStates));
      print('NostrService: Removed relay: $relayUrl');
    }
  }

  @override
  Future<void> setRelays(List<String> relayUrls) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    // Remove current relays
    for (final relay in List.from(_externalRelays)) {
      await removeRelay(relay);
    }
    
    // Add new relays
    for (final relay in relayUrls) {
      await addRelay(relay);
    }
  }

  Future<Event?> getEvent(String eventId) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    final embeddedEvent = await _embeddedRelay.getEvent(eventId);
    if (embeddedEvent != null) {
      return _convertFromEmbeddedEvent(embeddedEvent);
    }
    return null;
  }

  Future<List<Event>> getEvents({required List<Filter> filters, int? limit}) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    final embeddedFilters = filters.map(_convertToEmbeddedFilter).toList();
    
    // Apply limit to first filter if provided
    if (limit != null && embeddedFilters.isNotEmpty) {
      embeddedFilters[0] = embedded.Filter(
        ids: embeddedFilters[0].ids,
        authors: embeddedFilters[0].authors,
        kinds: embeddedFilters[0].kinds,
        since: embeddedFilters[0].since,
        until: embeddedFilters[0].until,
        limit: limit,
        tags: embeddedFilters[0].tags,
      );
    }
    
    final embeddedEvents = await _embeddedRelay.queryEvents(embeddedFilters);
    
    return embeddedEvents.map(_convertFromEmbeddedEvent).toList();
  }

  void unsubscribe(String subscriptionId) {
    final controller = _subscriptions[subscriptionId];
    if (controller != null) {
      controller.close();
      _subscriptions.remove(subscriptionId);
    }
    
    final subscription = _relaySubscriptions[subscriptionId];
    if (subscription != null) {
      subscription.close();
      _relaySubscriptions.remove(subscriptionId);
    }
  }

  @override
  void closeSubscription(String subscriptionId) {
    unsubscribe(subscriptionId);
  }

  @override
  Future<void> requestNip42Auth(String relayUrl, Event authEvent) async {
    // Handle NIP-42 authentication if needed
    _relayAuthStates[relayUrl] = true;
    _authStateController.add(Map.from(_relayAuthStates));
  }

  // Helper methods for event conversion between nostr_sdk and embedded relay

  embedded.Filter _convertToEmbeddedFilter(Filter filter) {
    // Convert nostr_sdk Filter to embedded relay Filter
    final Map<String, List<String>> genericTags = {};
    
    // Convert h tags (hashtags) if they exist
    if (filter.h != null && filter.h!.isNotEmpty) {
      genericTags['h'] = filter.h!;
    }
    
    // Note: Filter from nostr_sdk doesn't have a 'tags' property,
    // only specific tag filters like h, e, p, etc.
    
    return embedded.Filter(
      ids: filter.ids,
      authors: filter.authors,
      kinds: filter.kinds,
      since: filter.since,
      until: filter.until,
      limit: filter.limit,
      tags: genericTags.isNotEmpty ? genericTags : null,
    );
  }

  embedded.NostrEvent _convertToEmbeddedEvent(Event event) {
    return embedded.NostrEvent(
      id: event.id,
      pubkey: event.pubkey,
      createdAt: event.createdAt,
      kind: event.kind,
      tags: List<List<String>>.from(event.tags.map((tag) => 
        tag is List ? List<String>.from(tag.map((e) => e.toString())) : <String>[])),
      content: event.content,
      sig: event.sig,
    );
  }

  Event _convertFromEmbeddedEvent(embedded.NostrEvent embeddedEvent) {
    // The Event constructor from nostr_sdk doesn't take id and sig as named parameters
    // They are calculated/set after construction
    final event = Event(
      embeddedEvent.pubkey,
      embeddedEvent.kind,
      embeddedEvent.tags,
      embeddedEvent.content,
      createdAt: embeddedEvent.createdAt,
    );
    
    // Set the id and signature that were already calculated
    event.id = embeddedEvent.id;
    event.sig = embeddedEvent.sig;
    
    return event;
  }

  Future<void> signAndBroadcastEvent(Map<String, dynamic> eventData) async {
    if (!hasKeys) throw StateError('No keys available for signing');
    
    // Create and sign event
    final unsignedEvent = Event(
      publicKey!,
      eventData['kind'],
      eventData['tags'] ?? [],
      eventData['content'] ?? '',
      createdAt: eventData['created_at'] ?? DateTime.now().millisecondsSinceEpoch ~/ 1000,
    );
    
    final signedEvent = await signEvent(unsignedEvent);
    await broadcastEvent(signedEvent);
  }

  Future<Event> signEvent(Event event) async {
    // NostrKeyManager doesn't have signEvent, need to use Event's sign method
    final privateKey = _keyManager.privateKey;
    if (privateKey == null) throw StateError('No private key available');
    
    // Event class has a sign method that modifies the event in place
    event.sign(privateKey);
    return event;
  }

  // Compatibility methods for existing code

  Event createEvent({
    required int kind,
    required String content,
    List<List<String>>? tags,
  }) {
    if (!hasKeys) throw StateError('No keys available');
    
    return Event(
      publicKey!,
      kind,
      tags ?? [],
      content,
      createdAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
    );
  }

  @override
  Future<NostrBroadcastResult> publishFileMetadata({
    required NIP94Metadata metadata,
    required String content,
    List<String> hashtags = const [],
  }) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    // Create event with file metadata
    final tags = [
      ['url', metadata.url],
      ['m', metadata.mimeType],
      ['x', metadata.sha256Hash],
      ['size', metadata.sizeBytes.toString()],
      ...hashtags.map((tag) => ['t', tag]),
    ];
    
    final event = createEvent(
      kind: 1063, // NIP-94 file metadata
      content: content,
      tags: tags,
    );
    
    final signedEvent = await signEvent(event);
    return await broadcastEvent(signedEvent);
  }

  @override
  Map<String, bool> getRelayStatus() {
    return Map.from(_relayAuthStates);
  }

  @override
  Future<void> reconnectAll() async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    // Re-connect to all external relays
    for (final relayUrl in _externalRelays) {
      try {
        await _embeddedRelay.removeExternalRelay(relayUrl);
        await _embeddedRelay.addExternalRelay(relayUrl);
        _relayAuthStates[relayUrl] = true;
      } catch (e) {
        print('NostrService: Failed to reconnect to $relayUrl: $e');
        _relayAuthStates[relayUrl] = false;
      }
    }
    _authStateController.add(Map.from(_relayAuthStates));
  }

  @override
  Future<void> closeAllSubscriptions() async {
    for (final controller in _subscriptions.values) {
      await controller.close();
    }
    _subscriptions.clear();
    
    for (final sub in _relaySubscriptions.values) {
      sub.close();
    }
    _relaySubscriptions.clear();
  }

  @override
  Stream<Event> searchVideos(String query, {
    List<String>? authors,
    DateTime? since,
    DateTime? until,
    int? limit,
  }) {
    // NIP-50 search implementation using content search
    final filters = [
      Filter(
        kinds: [32222], // Video events
        authors: authors,
        since: since != null ? since.millisecondsSinceEpoch ~/ 1000 : null,
        until: until != null ? until.millisecondsSinceEpoch ~/ 1000 : null,
        limit: limit,
        // Note: NIP-50 search would use 'search' tag, but Filter doesn't support custom tags directly
        // The search needs to be handled by filtering the content field
      ),
    ];
    
    // Create a filtered stream that checks content for the query
    return subscribeToEvents(filters: filters).where((event) {
      return event.content.toLowerCase().contains(query.toLowerCase());
    });
  }

  @override
  String get primaryRelay => _externalRelays.isNotEmpty 
      ? _externalRelays.first 
      : 'embedded://local';

  /// Discover and add relays from a user's profile (kind 0 and kind 10002 events)
  /// This implements NIP-65 relay list metadata
  Future<void> discoverUserRelays(String pubkey) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    try {
      // Query for kind 0 (profile) events
      final profileEvents = await getEvents(
        filters: [
          Filter(
            kinds: [0], // User metadata
            authors: [pubkey],
            limit: 1,
          ),
        ],
      );
      
      if (profileEvents.isNotEmpty) {
        final profileEvent = profileEvents.first;
        // Parse profile content for relay hints
        try {
          final content = profileEvent.content;
          // Check if content contains relay URLs (some clients include them)
          final relayPattern = RegExp(r'wss?://[^\s,"\}]+');
          final matches = relayPattern.allMatches(content);
          
          for (final match in matches) {
            final relayUrl = match.group(0);
            if (relayUrl != null && !_externalRelays.contains(relayUrl)) {
              await addRelay(relayUrl);
              print('NostrService: Discovered relay from profile: $relayUrl');
            }
          }
        } catch (e) {
          print('NostrService: Error parsing profile for relays: $e');
        }
      }
      
      // Query for kind 10002 (relay list metadata) - NIP-65
      final relayListEvents = await getEvents(
        filters: [
          Filter(
            kinds: [10002], // Relay list metadata
            authors: [pubkey],
            limit: 1,
          ),
        ],
      );
      
      if (relayListEvents.isNotEmpty) {
        final relayListEvent = relayListEvents.first;
        // Parse relay list from tags
        for (final tag in relayListEvent.tags) {
          if (tag.isNotEmpty && tag[0] == 'r' && tag.length > 1) {
            final relayUrl = tag[1];
            if (!_externalRelays.contains(relayUrl)) {
              // Check for read/write markers if present
              final isWrite = tag.length > 2 && tag[2] == 'write';
              final isRead = tag.length > 2 && tag[2] == 'read';
              
              await addRelay(relayUrl);
              print('NostrService: Discovered relay from NIP-65: $relayUrl (write: $isWrite, read: $isRead)');
            }
          }
        }
      }
      
      // Also check for kind 3 (contact list) which sometimes includes relay hints
      final contactListEvents = await getEvents(
        filters: [
          Filter(
            kinds: [3], // Contact list
            authors: [pubkey],
            limit: 1,
          ),
        ],
      );
      
      if (contactListEvents.isNotEmpty) {
        final contactEvent = contactListEvents.first;
        // Some clients store relay URLs in the content field as JSON
        try {
          final content = contactEvent.content;
          if (content.isNotEmpty) {
            final relayPattern = RegExp(r'wss?://[^\s,"\}]+');
            final matches = relayPattern.allMatches(content);
            
            for (final match in matches) {
              final relayUrl = match.group(0);
              if (relayUrl != null && !_externalRelays.contains(relayUrl)) {
                await addRelay(relayUrl);
                print('NostrService: Discovered relay from contact list: $relayUrl');
              }
            }
          }
        } catch (e) {
          print('NostrService: Error parsing contact list for relays: $e');
        }
      }
    } catch (e) {
      print('NostrService: Error discovering user relays: $e');
    }
  }

  /// Add relays that are commonly used by a user based on their event history
  Future<void> discoverRelaysFromEventHints(String pubkey) async {
    if (_isDisposed) throw StateError('NostrService is disposed');
    if (!_isInitialized) throw StateError('NostrService not initialized');
    
    try {
      // Get recent events from the user
      final userEvents = await getEvents(
        filters: [
          Filter(
            authors: [pubkey],
            limit: 20, // Check last 20 events for relay hints
          ),
        ],
      );
      
      final discoveredRelays = <String>{};
      
      for (final event in userEvents) {
        // Check for relay hints in tags
        for (final tag in event.tags) {
          if (tag.length >= 3 && (tag[0] == 'e' || tag[0] == 'p')) {
            // NIP-01: ["e", <event-id>, <relay-url>] or ["p", <pubkey>, <relay-url>]
            final relayHint = tag.length > 2 ? tag[2] : null;
            if (relayHint != null && relayHint.startsWith('wss://')) {
              discoveredRelays.add(relayHint);
            }
          }
        }
      }
      
      // Add discovered relays
      for (final relayUrl in discoveredRelays) {
        if (!_externalRelays.contains(relayUrl)) {
          await addRelay(relayUrl);
          print('NostrService: Discovered relay from event hints: $relayUrl');
        }
      }
    } catch (e) {
      print('NostrService: Error discovering relays from event hints: $e');
    }
  }
}